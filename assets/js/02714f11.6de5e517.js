"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[241],{3639:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>l,frontMatter:()=>s,metadata:()=>o,toc:()=>h});var t=i(4848),r=i(8453);const s={id:"model_query_basics",title:"Query Basics"},d="Query Basics",o={id:"Model/Querying/model_query_basics",title:"Query Basics",description:"MVOM allows consumers to execute queries against the database via the defined schema associated with a Model instance. Queries are constructed using MVOM's query language which are then translated into MultiValue queries. The results of the query are then returned as Model instances. MVOM exposes two static methods for issuing queries: find and findAndCount.",source:"@site/docs/04 - Model/06 - Querying/01 - Basics.md",sourceDirName:"04 - Model/06 - Querying",slug:"/Model/Querying/model_query_basics",permalink:"/mvom/docs/Model/Querying/model_query_basics",draft:!1,unlisted:!1,editUrl:"https://github.com/STORIS/mvom/tree/main/website/docs/04 - Model/06 - Querying/01 - Basics.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{id:"model_query_basics",title:"Query Basics"},sidebar:"docsSidebar",previous:{title:"Deleting a Model",permalink:"/mvom/docs/Model/model_deletion"},next:{title:"Query Conditional Operators",permalink:"/mvom/docs/Model/Querying/model_query_operators"}},c={},h=[{value:"find Method",id:"find-method",level:2},{value:"Syntax",id:"syntax",level:3},{value:"Parameters",id:"parameters",level:3},{value:"Options Object Properties",id:"options-object-properties",level:4},{value:"findAndCount Method",id:"findandcount-method",level:2},{value:"Syntax",id:"syntax-1",level:3},{value:"Parameters",id:"parameters-1",level:3},{value:"Return Value",id:"return-value",level:3},{value:"The Query Condition Filter Object",id:"the-query-condition-filter-object",level:2},{value:"Example",id:"example",level:3}];function a(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"query-basics",children:"Query Basics"}),"\n",(0,t.jsxs)(n.p,{children:["MVOM allows consumers to execute queries against the database via the defined schema associated with a ",(0,t.jsx)(n.code,{children:"Model"})," instance. Queries are constructed using MVOM's query language which are then translated into MultiValue queries. The results of the query are then returned as ",(0,t.jsx)(n.code,{children:"Model"})," instances. MVOM exposes two static methods for issuing queries: ",(0,t.jsx)(n.code,{children:"find"})," and ",(0,t.jsx)(n.code,{children:"findAndCount"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"find-method",children:"find Method"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"find"})," method accepts an MVOM query condition object and returns an array of ",(0,t.jsx)(n.code,{children:"Model"})," instances which matched the query's conditions."]}),"\n",(0,t.jsx)(n.h3,{id:"syntax",children:"Syntax"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"static find(queryCondition: Filter, options?: ModelFindOptions): Promise<Model[]>\n"})}),"\n",(0,t.jsx)(n.h3,{id:"parameters",children:"Parameters"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Parameter"}),(0,t.jsx)(n.th,{children:"Type"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"queryCondition"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"object"})}),(0,t.jsxs)(n.td,{children:["The ",(0,t.jsx)(n.a,{href:"#the-query-condition-filter-object",children:"query condition filter object"})]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"options"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"object"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.a,{href:"#options-object-properties",children:"Options object"})})]})]})]}),"\n",(0,t.jsx)(n.h4,{id:"options-object-properties",children:"Options Object Properties"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Property"}),(0,t.jsx)(n.th,{children:"Type"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"skip"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"number"})}),(0,t.jsxs)(n.td,{children:["The number of matching records to skip when returning results. See ",(0,t.jsx)(n.a,{href:"model_query_pagination",children:"pagination"}),"."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"limit"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"number"})}),(0,t.jsxs)(n.td,{children:["The number of matching records to return in the result set. See ",(0,t.jsx)(n.a,{href:"model_query_pagination",children:"pagination"}),"."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"sort"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)("code",{children:"[string, -1 | 1 ][]"})}),(0,t.jsxs)(n.td,{children:["The sort criteria for the query. See ",(0,t.jsx)(n.a,{href:"model_query_sorting",children:"sorting"}),"."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"projection"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"string[]"})}),(0,t.jsxs)(n.td,{children:["The ",(0,t.jsx)(n.a,{href:"../Advanced%20Topics/model_projection",children:"projection"})," of properties to return from the database"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"maxReturnPayloadSize"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"number"})}),(0,t.jsx)(n.td,{children:"The maximum allowed return payload size in bytes. If this size is exceeded a DbServerError will be thrown. If omitted the value specified during connection creation is used."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"requestId"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"string"})}),(0,t.jsxs)(n.td,{children:["A request/trace ID to be passed to MVIS as a request header with the key ",(0,t.jsx)(n.code,{children:"X-MVIS-Trace-Id"})]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"userDefined"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"object"})}),(0,t.jsxs)(n.td,{children:["The ",(0,t.jsx)(n.a,{href:"../Advanced%20Topics/model_user_defined_options",children:"user defined options"})," to pass to the database subroutines"]})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"findandcount-method",children:"findAndCount Method"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"findAndCount"})," method accepts an MVOM query condition object and returns an array of ",(0,t.jsx)(n.code,{children:"Model"})," instances which matched the query's conditions as well as a count of the total number of records which matched the query's conditions. This count value can be useful when executing ",(0,t.jsx)(n.a,{href:"model_query_pagination",children:"paginated queries"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"syntax-1",children:"Syntax"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"static findAndCount(queryCondition: Filter, options?: ModelFindOptions): Promise<ModelFindAndCountResult>\n"})}),"\n",(0,t.jsx)(n.h3,{id:"parameters-1",children:"Parameters"}),"\n",(0,t.jsxs)(n.p,{children:["The parameters for ",(0,t.jsx)(n.code,{children:"findAndCount"})," are the same as for ",(0,t.jsx)(n.a,{href:"#parameters",children:"find"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"return-value",children:"Return Value"}),"\n",(0,t.jsxs)(n.p,{children:["The return value of ",(0,t.jsx)(n.code,{children:"findAndCount"})," is an object with the following properties:"]}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Property"}),(0,t.jsx)(n.th,{children:"Type"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"count"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"number"})}),(0,t.jsx)(n.td,{children:"The total number of records which matched the query condition"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"documents"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Model[]"})}),(0,t.jsxs)(n.td,{children:["The ",(0,t.jsx)(n.code,{children:"Model"})," instances which were returned by the query"]})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"the-query-condition-filter-object",children:"The Query Condition Filter Object"}),"\n",(0,t.jsxs)(n.p,{children:["When issuing queries, a query condition filter object must be passed to the ",(0,t.jsx)(n.code,{children:"find"})," or ",(0,t.jsx)(n.code,{children:"findAndCount"})," methods. This query condition filter object has properties which correspond to the properties of the ",(0,t.jsx)(n.code,{children:"Schema"})," which are assigned values which define the condition for the query. The general format of a query condition filter object is:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"{\n  propertyName1: {\n    conditionalOperator: conditionalValue,\n  },\n  propertyName2: {\n    conditionalOperator: conditionalValue,\n  }\n}\n"})}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:["In order to use a property for a query it must either be a property defined in the schema with a specified ",(0,t.jsx)(n.a,{href:"../../Schema/schema_basics#properties-common-to-all-schema-definition-types",children:"dictionary"})," value or a property defined in the ",(0,t.jsx)(n.a,{href:"../../Schema/schema_options#dictionaries-object",children:"dictionaries object"})," of the schema options."]})}),"\n",(0,t.jsx)(n.h3,{id:"example",children:"Example"}),"\n",(0,t.jsx)(n.p,{children:"Consider a scenario where you want to query for all items which have a price greater than 100. The following example code illustrates construction of a query to satisfy that requirement."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"const schema = new Schema({\n  description: { type: 'string', path: 1, dictionary: 'DESCRIPTION' },\n  price: { type: 'number', path: 2, dbDecimals: 2, dictionary: 'PRICE' },\n});\n\nconst Item = connection.model(schema, 'ITEM');\n\nconst items = await Item.find({ price: { $gt: 100 } });\n"})}),"\n",(0,t.jsxs)(n.p,{children:["In the above example, ",(0,t.jsx)(n.code,{children:"price"})," is the schema property which is being queried against. ",(0,t.jsx)(n.code,{children:"$gt"})," is the greater than operator and ",(0,t.jsx)(n.code,{children:"100"})," is the value to be compared."]}),"\n",(0,t.jsx)(n.p,{children:"The query which will be executed on the MultiValue database is:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'select ITEM with PRICE > "100"\n'})}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsxs)(n.p,{children:["If you provide a ",(0,t.jsx)(n.a,{href:"../../connection#logger-interface",children:"logger"})," to your ",(0,t.jsx)(n.code,{children:"Connection"}),", the transformed MultiValue query will be passed to the ",(0,t.jsx)(n.code,{children:"debug"})," method."]})})]})}function l(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>d,x:()=>o});var t=i(6540);const r={},s=t.createContext(r);function d(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:d(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);