"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[827],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return h}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function d(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),s=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=s(e.components);return a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,c=d(e,["components","mdxType","originalType","parentName"]),m=s(n),h=r,u=m["".concat(l,".").concat(h)]||m[h]||p[h]||i;return n?a.createElement(u,o(o({ref:t},c),{},{components:n})):a.createElement(u,o({ref:t},c))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=m;var d={};for(var l in t)hasOwnProperty.call(t,l)&&(d[l]=t[l]);d.originalType=e,d.mdxType="string"==typeof e?e:r,o[1]=d;for(var s=2;s<i;s++)o[s]=n[s];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},2935:function(e,t,n){n.r(t),n.d(t,{assets:function(){return c},contentTitle:function(){return l},default:function(){return h},frontMatter:function(){return d},metadata:function(){return s},toc:function(){return p}});var a=n(7462),r=n(3366),i=(n(7294),n(3905)),o=["components"],d={id:"model_saving",title:"Saving a Model"},l="Saving a Model",s={unversionedId:"Model/model_saving",id:"Model/model_saving",title:"Saving a Model",description:"An instance of a Model can be saved to the database. This save operation can either be the insertion of a new record into the database or the update to an existing record.",source:"@site/docs/04 - Model/04 - Saving a Model.md",sourceDirName:"04 - Model",slug:"/Model/model_saving",permalink:"/mvom/docs/Model/model_saving",draft:!1,editUrl:"https://github.com/STORIS/mvom/tree/main/website/docs/04 - Model/04 - Saving a Model.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{id:"model_saving",title:"Saving a Model"},sidebar:"docsSidebar",previous:{title:"Reading a Model By ID",permalink:"/mvom/docs/Model/model_reading_by_id"},next:{title:"Deleting a Model",permalink:"/mvom/docs/Model/model_deletion"}},c={},p=[{value:"save Method",id:"save-method",level:2},{value:"Syntax",id:"syntax",level:3},{value:"Parameters",id:"parameters",level:3},{value:"Options Object Properties",id:"options-object-properties",level:4},{value:"Example (Inserting a Record)",id:"example-inserting-a-record",level:3},{value:"Example (Updating a Record)",id:"example-updating-a-record",level:3},{value:"Record Insertion Notes",id:"record-insertion-notes",level:2},{value:"Record Locks",id:"record-locks",level:3},{value:"Record Existence",id:"record-existence",level:3},{value:"Record Update Notes",id:"record-update-notes",level:2},{value:"Handling of attributes which are not defined in the schema",id:"handling-of-attributes-which-are-not-defined-in-the-schema",level:3},{value:"Record Locks",id:"record-locks-1",level:3},{value:"Record Changes",id:"record-changes",level:3}],m={toc:p};function h(e){var t=e.components,n=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"saving-a-model"},"Saving a Model"),(0,i.kt)("p",null,"An instance of a ",(0,i.kt)("inlineCode",{parentName:"p"},"Model")," can be saved to the database. This save operation can either be the insertion of a new record into the database or the update to an existing record."),(0,i.kt)("h2",{id:"save-method"},"save Method"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"save")," method inserts or updates an existing record into the database with the contents of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Model")," instance. Prior to saving, the Model is validated to ensure that required values are specified, data can be properly cast into the corresponding database value, and foreign key constraints have been satisfied."),(0,i.kt)("h3",{id:"syntax"},"Syntax"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"save(options?: ModelSaveOptions): Promise<Model>\n")),(0,i.kt)("h3",{id:"parameters"},"Parameters"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,i.kt)("th",{parentName:"tr",align:null},"Type"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"options")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"object")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("a",{parentName:"td",href:"#options-object-properties"},"Options object")," (see below)")))),(0,i.kt)("h4",{id:"options-object-properties"},"Options Object Properties"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Property"),(0,i.kt)("th",{parentName:"tr",align:null},"Type"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"maxReturnPayloadSize")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"number")),(0,i.kt)("td",{parentName:"tr",align:null},"The maximum allowed return payload size in bytes. If this size is exceeded a DbServerError will be thrown. If omitted the value specified during connection creation is used.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"requestId")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"string")),(0,i.kt)("td",{parentName:"tr",align:null},"A request/trace ID to be passed to MVIS as a request header with the key ",(0,i.kt)("inlineCode",{parentName:"td"},"X-MVIS-Trace-Id"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"userDefined")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"object")),(0,i.kt)("td",{parentName:"tr",align:null},"The ",(0,i.kt)("a",{parentName:"td",href:"./Advanced%20Topics/model_user_defined_options"},"user defined options")," to pass to the database subroutines")))),(0,i.kt)("h3",{id:"example-inserting-a-record"},"Example (Inserting a Record)"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const schema = new Schema({\n  description: { type: 'string', path: 1 },\n  price: { type: 'number', path: 2, dbDecimals: 2 },\n});\n\nconst Item = connection.model(schema, 'ITEM');\n\nconst item = new Item({ _id: '0001', data: { description: 'Racecar Bed', price: 999.99 } });\n\nconst savedItem = await item.save();\n")),(0,i.kt)("h3",{id:"example-updating-a-record"},"Example (Updating a Record)"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const schema = new Schema({\n  description: { type: 'string', path: 1 },\n  price: { type: 'number', path: 2, dbDecimals: 2 },\n});\n\nconst Item = connection.model(schema, 'ITEM');\n\nconst item = await Item.findById('0001');\n\nitem.price = 899.99;\nconst updatedItem = await item.save();\nconsole.log(updatedItem.price); // outputs 899.99\n")),(0,i.kt)("h2",{id:"record-insertion-notes"},"Record Insertion Notes"),(0,i.kt)("h3",{id:"record-locks"},"Record Locks"),(0,i.kt)("p",null,"MVOM will reject any database insertions for a record that is currently locked (e.g. a ",(0,i.kt)("inlineCode",{parentName:"p"},"READU")," statement). In this scenario, ",(0,i.kt)("inlineCode",{parentName:"p"},"save")," will reject with a ",(0,i.kt)("inlineCode",{parentName:"p"},"RecordLockedError"),"."),(0,i.kt)("h3",{id:"record-existence"},"Record Existence"),(0,i.kt)("p",null,"If a ",(0,i.kt)("inlineCode",{parentName:"p"},"save")," operation is performed with a ",(0,i.kt)("inlineCode",{parentName:"p"},"Model")," instance that was created via the ",(0,i.kt)("inlineCode",{parentName:"p"},"new")," operator, the record with the ID corresponding to the ",(0,i.kt)("inlineCode",{parentName:"p"},"_id")," property of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Model")," must not exist. If the record already exists, ",(0,i.kt)("inlineCode",{parentName:"p"},"save")," will reject with a ",(0,i.kt)("inlineCode",{parentName:"p"},"DocumentVersionMismatchError"),"."),(0,i.kt)("h2",{id:"record-update-notes"},"Record Update Notes"),(0,i.kt)("h3",{id:"handling-of-attributes-which-are-not-defined-in-the-schema"},"Handling of attributes which are not defined in the schema"),(0,i.kt)("p",null,"MVOM does not require that the entirety of a record structure be defined in the schema. This ability allows you to only invest in defining the schema for those properties which are important for the current use case. When updating an existing record, MVOM will only modify properties which are defined by the schema. That is, any attributes which are not defined in the schema will be left unchanged when updating an existing record."),(0,i.kt)("h3",{id:"record-locks-1"},"Record Locks"),(0,i.kt)("p",null,"MVOM will reject any database updates for a record that is currently locked (e.g. a ",(0,i.kt)("inlineCode",{parentName:"p"},"READU")," statement). In this scenario, ",(0,i.kt)("inlineCode",{parentName:"p"},"save")," will reject with a ",(0,i.kt)("inlineCode",{parentName:"p"},"RecordLockedError"),"."),(0,i.kt)("p",null,"In scenarios where locks are intended to be transient, we suggest that you implement retry logic to attempt to save the record again."),(0,i.kt)("h3",{id:"record-changes"},"Record Changes"),(0,i.kt)("p",null,"When a record is read, a ",(0,i.kt)("a",{parentName:"p",href:"./Advanced%20Topics/model_version"},"version string")," is generated by hashing the contents of the record. This version is stored with the ",(0,i.kt)("inlineCode",{parentName:"p"},"Model")," instance in the ",(0,i.kt)("inlineCode",{parentName:"p"},"__v")," property. When saving a record, this version is compared against the current state of the database record on disk. If the version has changed since the record was read, MVOM will not write the record. When the versions are mismatched, ",(0,i.kt)("inlineCode",{parentName:"p"},"save")," will reject with a ",(0,i.kt)("inlineCode",{parentName:"p"},"DocumentVersionMismatchError"),"."),(0,i.kt)("p",null,"For records which change often, you should try to read and write the record with as little time between the operations as possible. Similar to handling record locks, implementing retry logic to read, update, and save the record may be beneficial."))}h.isMDXComponent=!0}}]);