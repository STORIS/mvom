"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[4420],{9922:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>c,frontMatter:()=>s,metadata:()=>d,toc:()=>o});var n=i(4848),r=i(8453);const s={id:"schema_type_string",title:"String"},a="String Schema Type",d={id:"Schema/Scalar Schema Types/schema_type_string",title:"String",description:"The string schema type is the simplest of the schema types supported by MVOM.",source:"@site/docs/03 - Schema/02 - Scalar Schema Types/01 - String.md",sourceDirName:"03 - Schema/02 - Scalar Schema Types",slug:"/Schema/Scalar Schema Types/schema_type_string",permalink:"/mvom/docs/Schema/Scalar Schema Types/schema_type_string",draft:!1,unlisted:!1,editUrl:"https://github.com/STORIS/mvom/tree/main/website/docs/03 - Schema/02 - Scalar Schema Types/01 - String.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{id:"schema_type_string",title:"String"},sidebar:"docsSidebar",previous:{title:"Schema Basics",permalink:"/mvom/docs/Schema/schema_basics"},next:{title:"Boolean",permalink:"/mvom/docs/Schema/Scalar Schema Types/schema_type_boolean"}},l={},o=[{value:"Schema Definition Properties",id:"schema-definition-properties",level:2},{value:"Formatting",id:"formatting",level:2},{value:"Validating enumerations",id:"validating-enumerations",level:2},{value:"Validating pattern matching",id:"validating-pattern-matching",level:2},{value:"Validating foreign keys",id:"validating-foreign-keys",level:2},{value:"Properties of foreign key validator",id:"properties-of-foreign-key-validator",level:3},{value:"Example",id:"example",level:4},{value:"Delimited string foreign key validation",id:"delimited-string-foreign-key-validation",level:4},{value:"Example",id:"example-1",level:5},{value:"Example",id:"example-2",level:2}];function h(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"string-schema-type",children:"String Schema Type"}),"\n",(0,n.jsx)(t.p,{children:"The string schema type is the simplest of the schema types supported by MVOM."}),"\n",(0,n.jsx)(t.h2,{id:"schema-definition-properties",children:"Schema Definition Properties"}),"\n",(0,n.jsxs)(t.p,{children:["In addition to the ",(0,n.jsx)(t.a,{href:"../schema_basics#properties-common-to-all-schema-definition-types",children:"base schema definition properties"})," the ",(0,n.jsx)(t.code,{children:"string"})," type has the following additional properties:"]}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Property"}),(0,n.jsx)(t.th,{children:"Type"}),(0,n.jsx)(t.th,{style:{textAlign:"center"},children:"Mandatory"}),(0,n.jsx)(t.th,{children:"Default"}),(0,n.jsx)(t.th,{children:"Description"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"type"})}),(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:'"string"'})}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"\u2714\ufe0f"}),(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{children:"The type literal for a string schema type"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"enum"})}),(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"string[]"})}),(0,n.jsx)(t.td,{style:{textAlign:"center"}}),(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{children:"If specified, value will be validated against this list of allowed values"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"match"})}),(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"RegExp"})}),(0,n.jsx)(t.td,{style:{textAlign:"center"}}),(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{children:"If specified, value will be matched against this regular expression"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"foreignKey"})}),(0,n.jsx)(t.td,{children:(0,n.jsx)(t.a,{href:"#validating-foreign-keys",children:"object"})}),(0,n.jsx)(t.td,{style:{textAlign:"center"}}),(0,n.jsx)(t.td,{}),(0,n.jsxs)(t.td,{children:["If specified, value will be validated for foreign key constraints.",(0,n.jsx)("br",{})," See link for details on format."]})]})]})]}),"\n",(0,n.jsx)(t.h2,{id:"formatting",children:"Formatting"}),"\n",(0,n.jsx)(t.p,{children:"A string schema type will not be formatted. The input and output values will remain the same."}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Database Value"}),(0,n.jsx)(t.th,{children:"JavaScript Value"})]})}),(0,n.jsx)(t.tbody,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"foo"})}),(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"foo"})})]})})]}),"\n",(0,n.jsx)(t.h2,{id:"validating-enumerations",children:"Validating enumerations"}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"enum"})," property allows you to specify an array of permitted values for string types. If the value of the property is not in this list an error will be thrown when saving."]}),"\n",(0,n.jsx)(t.h2,{id:"validating-pattern-matching",children:"Validating pattern matching"}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"match"})," property allows you to specify a regular expression which will validate the value to determine if there is a match of the regular expression. If the value of the property does not match the regular expression an error will be thrown when saving."]}),"\n",(0,n.jsx)(t.h2,{id:"validating-foreign-keys",children:"Validating foreign keys"}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"foreignKey"})," property allows for validation to ensure that the value is a foreign key to a record of one or more file(s). If the value of the property is not a foreign key to at least one of the specified files then an error will be thrown when saving."]}),"\n",(0,n.jsx)(t.h3,{id:"properties-of-foreign-key-validator",children:"Properties of foreign key validator"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Property"}),(0,n.jsx)(t.th,{children:"Type"}),(0,n.jsx)(t.th,{style:{textAlign:"center"},children:"Mandatory"}),(0,n.jsx)(t.th,{children:"Description"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"file"})}),(0,n.jsxs)(t.td,{children:[(0,n.jsx)(t.code,{children:"string"})," | ",(0,n.jsx)(t.code,{children:"string[]"})]}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"\u2714\ufe0f"}),(0,n.jsxs)(t.td,{children:["The name of the file(s) in the MultiValue database to validate against.",(0,n.jsx)("br",{}),"Foreign key validation will pass if the value is an id to ",(0,n.jsx)(t.em,{children:"any"})," of the listed files."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"entityName"})}),(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"string"})}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"\u2714\ufe0f"}),(0,n.jsxs)(t.td,{children:["A friendly name for the foreign entity being validated",(0,n.jsx)("br",{}),"Used for validation errors only"]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"keysToIgnore"})}),(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"string[]"})}),(0,n.jsx)(t.td,{style:{textAlign:"center"}}),(0,n.jsx)(t.td,{children:"A list of keys which will not be validated"})]})]})]}),"\n",(0,n.jsx)(t.h4,{id:"example",children:"Example"}),"\n",(0,n.jsxs)(t.p,{children:["Consider a value that is intended to be a foreign key to a file named ",(0,n.jsx)(t.code,{children:"ITEM"}),". The structure of the schema definition would be as follows:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",children:"const schemaDefinition = {\n  stringWithForeignKeyProperty: {\n    type: 'string',\n    path: 1,\n    dictionary: 'STRING_DICT',\n    required: true,\n    foreignKey: { file: 'ITEM', entityName: 'item' },\n  },\n};\n\nconst schema = new Schema(schemaDefinition);\n"})}),"\n",(0,n.jsx)(t.h4,{id:"delimited-string-foreign-key-validation",children:"Delimited string foreign key validation"}),"\n",(0,n.jsxs)(t.p,{children:["Foreign key validation can also be run against the parts of a delimited string. For instance, if you had a string formatted as ",(0,n.jsx)(t.code,{children:"{part1}*{part2}"})," (i.e. 2 parts with an asterisk delimiter), you can validate one or both parts as separate foreign key validations. In this case, the foreign key validation format is as follows:"]}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Property"}),(0,n.jsx)(t.th,{children:"Type"}),(0,n.jsx)(t.th,{style:{textAlign:"center"},children:"Mandatory"}),(0,n.jsx)(t.th,{children:"Description"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"[key: number]"}),(0,n.jsx)(t.td,{children:(0,n.jsx)(t.a,{href:"#properties-of-foreign-key-validator",children:"Foreign Key Validator Definition"})}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"\u2714\ufe0f"}),(0,n.jsxs)(t.td,{children:["One or more dynamic integer key values representing the 0-indexed position in the string after being split by the delimiter",(0,n.jsx)("br",{}),"The property value's type is the standard foreign key validation object.",(0,n.jsx)("br",{}),"Only those parts of the string which are to be validated require a definition (i.e. the undefined parts will be ignored)"]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"splitCharacter"})}),(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"string"})}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"\u2714\ufe0f"}),(0,n.jsx)(t.td,{children:"The string's delimiter character"})]})]})]}),"\n",(0,n.jsx)(t.h5,{id:"example-1",children:"Example"}),"\n",(0,n.jsxs)(t.p,{children:["Consider a string of the format ",(0,n.jsx)(t.code,{children:"{itemId}*{locationId}"})," which is a string delimited by an asterisk where the first part of the string is a foreign key to a file named ",(0,n.jsx)(t.code,{children:"ITEM"})," and the second part of the string is a foreign key to a file named ",(0,n.jsx)(t.code,{children:"LOCATION"}),". The structure of the schema definition would appear as follows:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",children:"const schemaDefinition = {\n  compoundStringWithForeignKeyProperty: {\n    type: 'string',\n    path: 1,\n    dictionary: 'STRING_DICT',\n    required: true,\n    foreignKey: {\n      0: { file: 'ITEM', entityName: 'item' },\n      1: { file: 'LOCATION', entityName: 'location' },\n      splitCharacter: '*',\n    },\n  },\n};\n\nconst schema = new Schema(schemaDefinition);\n"})}),"\n",(0,n.jsx)(t.h2,{id:"example-2",children:"Example"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",children:"const schemaDefinition = {\n  stringProperty: {\n    type: 'string',\n    path: 1,\n    dictionary: 'STRING_DICT',\n    required: true,\n    enum: ['foo', 'bar', 'baz'],\n  },\n};\n\nconst schema = new Schema(schemaDefinition);\n"})})]})}function c(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},8453:(e,t,i)=>{i.d(t,{R:()=>a,x:()=>d});var n=i(6540);const r={},s=n.createContext(r);function a(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function d(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);