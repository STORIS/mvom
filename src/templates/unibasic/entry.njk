$basictype 'U'
subroutine mvom_entry(input, output)
{% include "./partials/udoConstants.njk" %}

{% include "./partials/errorConstants.njk" %}

* eliminate all output
hush on

* ensure compact serialized json output
if udoSetOption(UDOOPTION_OUTPUTMODE, UDO_OUTPUT_COMPACT) then
  call error_handler(ERROR_UDO, outputHandle)
  go response
end

* default responses
if udoCreate(UDO_OBJECT, outputHandle) then
  call error_handler(ERROR_UDO, outputHandle)
  go response
end

* start main program processing

if udoRead(input, UDOFORMAT_JSON, handle) then
  call error_handler(ERROR_MALFORMED_INPUT, outputHandle)
  go response
end

if udoGetProperty(handle, 'action', action, type) then
  call error_handler(ERROR_MALFORMED_INPUT, outputHandle)
  go response
end

begin case
  case action eq 'programList'
    * return the name of all files in the specified directory which are globally cataloged
    if udoGetProperty(handle, 'sourceDir', sourceDir, type) then
      call error_handler(ERROR_MALFORMED_INPUT, outputHandle)
      go response
    end

    open sourceDir readonly to f.sourceDir on error
      call error_handler(ERROR_FILE_OPEN, outputHandle)
      go response
    end else
      call error_handler(ERROR_FILE_OPEN, outputHandle)
      go response
    end

    open 'CTLGTB' readonly to f.catalog on error
      close f.sourceDir
      call error_handler(ERROR_FILE_OPEN, outputHandle)
      go response
    end else
      close f.sourceDir
      call error_handler(ERROR_FILE_OPEN, outputHandle)
      go response
    end

    if udoCreate(UDO_ARRAY, programList) then
      close f.sourceDir
      close f.catalog
      call error_handler(ERROR_UDO, outputHandle)
      go response
    end

    if udoSetProperty(outputHandle, 'programs', programList) then
      close f.sourceDir
      close f.catalog
      call error_handler(ERROR_UDO, outputHandle)
      go response
    end

    select f.sourceDir
    loop readnext sourceKey else exit
      if sourceKey[1] <> '_' then
        * ignore probable object code
        readv test from f.catalog, sourceKey, 0 on error
          close f.sourceDir
          close f.catalog
          call error_handler(ERROR_READ, outputHandle)
          go response
        end then
          * only include items in the global catalog table
          if udoArrayAppendItem(programList, sourceKey) then
            close f.sourceDir
            close f.catalog
            call error_handler(ERROR_UDO, outputHandle)
            go response
          end
        end
      end
    repeat

    close f.sourceDir
    close f.catalog
  case action eq 'deploy'
    * deploy source code
    if udoGetProperty(handle, 'sourceDir', sourceDir, type) then
      call error_handler(ERROR_MALFORMED_INPUT, outputHandle)
      go response
    end

    if udoGetProperty(handle, 'source', source, type) then
      call error_handler(ERROR_MALFORMED_INPUT, outputHandle)
      go response
    end

    if udoGetProperty(handle, 'programName', programName, type) then
      call error_handler(ERROR_MALFORMED_INPUT, outputHandle)
      go response
    end

    open sourceDir to f.sourceDir on error
      call error_handler(ERROR_FILE_OPEN, outputHandle)
      go response
    end else
      call error_handler(ERROR_FILE_OPEN, outputHandle)
      go response
    end

    write source on f.sourceDir, programName on error
      close f.sourceDir
      call error_handler(ERROR_WRITE, outputHandle)
      go response
    end

    close f.sourceDir

    * compiling with override and case-insensitive flags
    execute 'basic ':sourceDir:' ':programName:' -o -i' returning errmsg
    if @system.return.code then
      call error_handler(ERROR_DEPLOYMENT, outputHandle)
      go response
    end

    * cataloging with default catalog (global) with force override
    execute 'catalog ':sourceDir:' ':programName:' force' returning errmsg
    if @system.return.code then
      call error_handler(ERROR_DEPLOYMENT, outputHandle)
      go response
    end

    if udoSetProperty(outputHandle, 'deployed', programName) then
      call error_handler(ERROR_UDO, outputHandle)
      go response
    end
  case action eq 'subroutine'
    * call specified subroutine
    if udoGetProperty(handle, 'subName', subName, type) then
      call error_handler(ERROR_MALFORMED_INPUT, outputHandle)
      go response
    end

    if udoGetProperty(handle, 'subInput', subInput, type) then
      call error_handler(ERROR_MALFORMED_INPUT, outputHandle)
      go response
    end

    call @subName(subInput, outputHandle, errorCode)
  case 1
    call error_handler(ERROR_UNSUPPORTED_ACTION, outputHandle)
    go response
end case

response:
  if udoWrite(outputHandle, UDOFORMAT_JSON, output) then
    close f.sourceDir
    close f.catalog
    call error_handler(ERROR_UDO, outputHandle)
    return; * returning to caller
  end

  if udoFree(outputHandle) then
    close f.sourceDir
    close f.catalog
    call error_handler(ERROR_UDO, outputHandle)
    return; * returning to caller
  end
  return; * returning to caller

{% include "./partials/errorHandler.njk" %}
