$basictype 'u'
subroutine mvom_save(options, output)
* save a document given a filename, record id, and record contents
{% include "./partials/udoConstants.njk" %}

{% include "./partials/errorConstants.njk" %}

* get the filename from the options
if udoGetProperty(options, 'filename', filename, type) then
  call error_handler(ERROR_MALFORMED_INPUT, output)
  go returnFromSub
end

* get the recordId from the options
if udoGetProperty(options, 'id', recordId, type) then
  call error_handler(ERROR_MALFORMED_INPUT, output)
  go returnFromSub
end

* get the previous record version (if any) from the options
if udoGetProperty(options, '__v', recordHash, recordHashType) then
  call error_handler(ERROR_MALFORMED_INPUT, output)
  go returnFromSub
end
if recordHashType eq UDO_NULL then
  recordHash = ''
end

* get the clearAttributes flag from the options
if udoGetProperty(options, 'clearAttributes', clearAttributes, clearAttributesType) then
  call error_handler(ERROR_MALFORMED_INPUT, output)
  go returnFromSub
end

* get the record contents from the options
if udoGetProperty(options, 'record', recordContents, type) then
  call error_handler(ERROR_MALFORMED_INPUT, output)
  go returnFromSub
end

* get the foreign key definitions contents from the options
if udoGetProperty(options, 'foreignKeyDefinitions', fkDefinitions, type) then
  call error_handler(ERROR_MALFORMED_INPUT, output)
  go returnFromSub
end

* open the file
open filename to f.file on error
  call error_handler(ERROR_FILE_OPEN, output)
  go returnFromSub
end else
  call error_handler(ERROR_FILE_OPEN, output)
  go returnFromSub
end

* read and lock record from the file
readu record from f.file, recordId on error
  call error_handler(ERROR_RECORD_READ, output)
  go closeAndReturnFromSub
end locked
  call error_handler(ERROR_RECORD_LOCKED, output)
  go closeAndReturnFromSub
end then
  if record eq '' then
    * empty record
    originalRecordHash = ''
  end else
    if digest('MD5', record, 1, originalRecordHash) then
      errorCode = ERROR_DIGEST_HASH
      go closeReleaseAndReturnFromSub
    end

    originalRecordHash = oconv(originalRecordHash, 'MX0C')
  end

  if originalRecordHash ne recordHash then
    call error_handler(ERROR_RECORD_VERSION, output)
    go closeReleaseAndReturnFromSub
  end
end else
  if recordHash ne '' then
    * this record existed previously, reject the save
    call error_handler(ERROR_RECORD_VERSION, output)
    go closeReleaseAndReturnFromSub
  end

  record = ''
end

* validate any foreign keys before updating
call validate_foreign_keys(fkDefinitions, fkValidationErrors, errorCode)
if errorCode then
  call error_handler(errorCode, output)
  go returnFromSub
end

if udoSetProperty(output, 'foreignKeyValidationErrors', fkValidationErrors) then
  call error_handler(ERROR_UDO, output)
  go closeReleaseAndReturnFromSub
end

if udoArrayGetSize(fkValidationErrors, fkValidationErrorCount) then
  call error_handler(ERROR_UDO, output)
  go closeReleaseAndReturnFromSub
end

if fkValidationErrorCount > 0 then
  call error_handler(ERROR_FOREIGN_KEY, output)
  go closeReleaseAndReturnFromSub
end

if udoArrayGetSize(recordContents, lastAttribute) then
  call error_handler(ERROR_UDO, output)
  go closeReleaseAndReturnFromSub
end

* if the clearAttributes flag is set, we are dealing with a schema-less file meaning the record
* can be an array of varying length, so we need to clear the record to ensure updates overwrite
* the existing data instead of merging the new record with the current one
if clearAttributesType eq UDO_TRUE then
  record = ''
end

for attributeCounter = 1 to lastAttribute
  if udoArrayGetItem(recordContents, attributeCounter, attributeContents, attributeType) then
    call error_handler(ERROR_UDO, output)
    go closeReleaseAndReturnFromSub
  end

  begin case
    case attributeType eq UDO_ARRAY
      if udoArrayGetSize(attributeContents, lastValue) then
        call error_handler(ERROR_UDO, output)
        go closeReleaseAndReturnFromSub
      end

      record<attributeCounter> = ''

      for valueCounter = 1 to lastValue
        if udoArrayGetItem(attributeContents, valueCounter, valueContents, valueType) then
          call error_handler(ERROR_UDO, output)
          go closeReleaseAndReturnFromSub
        end

        begin case
          case valueType eq UDO_ARRAY
            if udoArrayGetSize(valueContents, lastSubvalue) then
              call error_handler(ERROR_UDO, output)
              go closeReleaseAndReturnFromSub
            end

            record<attributeCounter, valueCounter> = ''

            for subvalueCounter = 1 to lastSubvalue
              if udoArrayGetItem(valueContents, subvalueCounter, subvalueContents, subvalueType) then
                call error_handler(ERROR_UDO, output)
                go closeReleaseAndReturnFromSub
              end

              begin case
                case subvalueType eq UDO_NULL
                  record<attributeCounter, valueCounter, subvalueCounter> = ''
                case subvalueType eq UDO_NUMBER or subvalueType eq UDO_STRING
                  record<attributeCounter, valueCounter, subvalueCounter> = subvalueContents
                case 1
                  call error_handler(ERROR_MALFORMED_INPUT, output)
                  go closeReleaseAndReturnFromSub
              end case
            next subvalueCounter

          case valueType eq UDO_NULL
            record<attributeCounter, valueCounter> = ''
          case valueType eq UDO_NUMBER or valueType eq UDO_STRING
            record<attributeCounter, valueCounter> = valueContents
          case 1
            call error_handler(ERROR_MALFORMED_INPUT, output)
            go closeReleaseAndReturnFromSub
        end case
      next valueCounter

    case attributeType eq UDO_NULL
      record<attributeCounter> = ''
    case attributeType eq UDO_NUMBER or attributeType eq UDO_STRING
      record<attributeCounter> = attributeContents
    case 1
      call error_handler(ERROR_MALFORMED_INPUT, output)
      go closeReleaseAndReturnFromSub
  end case
next attributeCounter

* create emprty projection array
if udoCreate(UDO_ARRAY, projection) then
   call error_handler(ERROR_UDO, output)
   go closeAndReturnFromSub
end

* write out record
write record on f.file, recordId on error
  call error_handler(ERROR_RECORD_WRITE, output)
  go closeAndReturnFromSub
end

close f.file on error null

* format the modified record into an object structure
call format_document(record, recordId, projection, document, errorCode)
if errorCode then
  call error_handler(errorCode, output)
  go returnFromSub
end

* set the result property
if udoSetProperty(output, 'result', document) then
  call error_handler(ERROR_UDO, output)
  go returnFromSub
end

go returnFromSub;* skip close and release behaviors

closeReleaseAndReturnFromSub:
release f.file, recordId on error null
* fall through to close and return

closeAndReturnFromSub:
close f.file on error null
* fall through to return

returnFromSub:
return; * returning to caller

{% include "./partials/formatDocument.njk" %}

{% include "./partials/validateForeignKeys.njk" %}

{% include "./partials/errorHandler.njk" %}
