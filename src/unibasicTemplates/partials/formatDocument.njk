subroutine format_document(record, recordId, projection, document, errorCode)
* format a record into an output document structure
{% include "./udoConstants.njk" %}

{% include "./errorConstants.njk" %}

{% include "./remove.njk" %}

errorCode = ''

* get projection positions
projectionPositions = ''
loop
  statusCode = UDOArrayGetNextItem(projection, projectionPosition, type)
  if statusCode eq UDO_ERROR then
    * reach the end of the array
    exit
  end
  if statusCode ne UDO_SUCCESS then
    * any other possible error
    errorCode = ERROR_UDO
    go returnFromSub
  end
  projectionPositions<-1> = projectionPosition
repeat
maxProjectionPosition = maximum(projectionPositions)

* create output document object
if udoCreate(UDO_OBJECT, document) then
  errorCode = ERROR_UDO
  go returnFromSub
end

* set document _id property
if udoSetProperty(document, '_id', recordId) then
  errorCode = ERROR_UDO
  go returnFromSub
end

if record eq '' then
  * empty record
  if udoCreate(UDO_NULL, null) then
    errorCode = ERROR_UDO
    go returnFromSub
  end

  if udoSetProperty(document, '__v', null) then
    errorCode = ERROR_UDO
    go returnFromSub
  end
end else
  * create a hash of the record for versioning purposes
  if digest('MD5', record, 1, recordHash) then
    errorCode = ERROR_DIGEST_HASH
    go returnFromSub
  end

  * set document version property
  if udoSetProperty(document, '__v', oconv(recordHash, 'MX0C')) then
    errorCode = ERROR_UDO
    go returnFromSub
  end
end

* create udo array as container for the record
if udoCreate(UDO_ARRAY, recordContents) then
  errorCode = ERROR_UDO
  go returnFromSub
end

prevDelim = ''
valueContents = ''
subValueContents = ''

rmvDataRec = record
rmvDelimChar = ''
* track the attribute level position
attributePosition = 0

if udoCreate(UDO_NULL, nullValue) then
  errorCode = ERROR_UDO
  go returnFromSub
end

loop until (rmvDelimChar eq RMV_DELIM_END)
  gosub rmvRemove

  token = rmvDataStr
  delim = rmvDelimChar

  begin case
    case (delim eq RMV_DELIM_ATTRIBUTE or delim eq RMV_DELIM_END) and (prevDelim eq RMV_DELIM_ATTRIBUTE or prevDelim eq '')
      * append at the attribute level
      if maxProjectionPosition > 0 then
        attributePosition += 1
        if attributePosition > maxProjectionPosition then
          exit
        end else
          locate attributePosition in projectionPositions, 1 setting nothing else token = ''
        end
      end

      appendArray = recordContents
      gosub appendToArray
      if errorCode eq ERROR_UDO then
        go returnFromSub
      end
    case delim eq RMV_DELIM_VALUE and (prevDelim eq RMV_DELIM_ATTRIBUTE or prevDelim eq '')
      * starting a new value marked array
      if udoCreate(UDO_ARRAY, valueContents) then
        errorCode = ERROR_UDO
        go returnFromSub
      end

      appendArray = valueContents
      gosub appendToArray
      if errorCode eq ERROR_UDO then
        go returnFromSub
      end
    case delim eq RMV_DELIM_VALUE and prevDelim eq RMV_DELIM_VALUE
      * continuing a value marked array
      appendArray = valueContents
      gosub appendToArray
      if errorCode eq ERROR_UDO then
        go returnFromSub
      end
    case (delim eq RMV_DELIM_ATTRIBUTE or delim eq RMV_DELIM_END) and prevDelim eq RMV_DELIM_VALUE
      * completing the value marked array
      appendArray = valueContents
      gosub appendToArray
      if errorCode eq ERROR_UDO then
        go returnFromSub
      end

      if maxProjectionPosition > 0 then
         attributePosition += 1
         if attributePosition > maxProjectionPosition then
           exit
         end else
           locate attributePosition in projectionPositions, 1 setting nothing else
             * if an error occurs in freeing the memory space for the objects, we will ignore it as there is little else that can be done
             x = udoFree(valueContents)
             valueContents = nullValue
           end
         end
      end

      if udoArrayAppendItem(recordContents, valueContents) then
        errorCode = ERROR_UDO
        go returnFromSub
      end

      valueContents = ''
    case delim eq RMV_DELIM_SUBVALUE and prevDelim NE RMV_DELIM_SUBVALUE
      * starting a subvalued array
      if udoGetType(valueContents, type) then
        errorCode = ERROR_UDO
        go returnFromSub
      end

      if type NE UDO_ARRAY then
        * A subvalue array cannot be directly appended to recordContents
        * ie it's always a nested array so if we don't have a value marked array in progress, start one
        if udoCreate(UDO_ARRAY, valueContents) then
          errorCode = ERROR_UDO
          go returnFromSub
        end
      end

      if udoCreate(UDO_ARRAY, subValueContents) then
        errorCode = ERROR_UDO
        go returnFromSub
      end

      appendArray = subValueContents
      gosub appendToArray
      if errorCode eq ERROR_UDO then
        go returnFromSub
      end
    case delim eq RMV_DELIM_SUBVALUE and prevDelim eq RMV_DELIM_SUBVALUE
      * continuing a sub value marked array
      appendArray = subValueContents
      gosub appendToArray
      if errorCode eq ERROR_UDO then
        go returnFromSub
      end
    case delim ne RMV_DELIM_SUBVALUE and prevDelim eq RMV_DELIM_SUBVALUE
      * completing a subvalued array
      appendArray = subValueContents
      gosub appendToArray
      if errorCode eq ERROR_UDO then
        go returnFromSub
      end

      * Subvalue arrays can not be directly appended to the attribute array
      if udoArrayAppendItem(valueContents, subValueContents) then
        errorCode = ERROR_UDO
        go returnFromSub
      end
      subValueContents = ''

      if delim eq RMV_DELIM_ATTRIBUTE or delim eq RMV_DELIM_END then
        * moving on to a new attribute or finished the record. Append whatever we have
        if maxProjectionPosition > 0 then
            attributePosition += 1
            if attributePosition > maxProjectionPosition then
               exit
            end else
               locate attributePosition in projectionPositions, 1 setting nothing else
               * if an error occurs in freeing the memory space for the objects, we will ignore it as there is little else that can be done
                 x = udoFree(valueContents)
                 valueContents = nullValue
               end
            end
        end
        if udoArrayAppendItem(recordContents, valueContents) then
          errorCode = ERROR_UDO
          go returnFromSub
        end
        valueContents = ''
      end
    case 1
      * unknown condition. We are appending to the end of the array so we cannot simply skip this value
      * rather than returning incorrect data, return an error
      call error_handler(ERROR_MALFORMED_INPUT, output)
      go returnFromSub
  end case

  prevDelim = delim

repeat

* set document record property
if udoSetProperty(document, 'record', recordContents) then
  errorCode = ERROR_UDO
  go returnFromSub
end

returnFromSub:
return; * returning to caller

appendToArray:
  * token - value to append
  * appendArray - UDO reference to the array to append the token value to

  if token eq '' then
    if udoCreate(UDO_NULL, null) then
      errorCode = ERROR_UDO
      go appendToArrayX
    end
    if udoArrayAppendItem(appendArray, null) then
      errorCode = ERROR_UDO
      go appendToArrayX
    end
  end else
    if udoArrayAppendItem(appendArray, token) then
      errorCode = ERROR_UDO
      go appendToArrayX
    end
  end

appendToArrayX:
  return
